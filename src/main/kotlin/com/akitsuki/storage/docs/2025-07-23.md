# Alex Xu의 S3와 유사한 객체 저장소 시스템 설계

Alex Xu의 "System Design Interview Volume 2" 9장에서 제시하는 S3와 유사한 객체 저장소 시스템은 **고가용성, 확장성, 11-nines 내구성**을 목표로 하는 분산 아키텍처입니다. 시스템의 핵심 원칙은 **메타데이터와 객체 데이터의 분리**로, 메타데이터는 변경 가능하고 객체 데이터는 불변성을 유지한다.

## High-Level Architecture Overview

### 핵심 아키텍처 구성 요소

**컴포넌트 연결 관계:**
```
[Client] → [Load Balancer] → [API Service] 
                                  ↓
                            [IAM Service]
                                  ↓
                    [Metadata Service] ← → [Data Service]
                           ↓                      ↓
                [Metadata Database]    [Distributed Storage]
```

**데이터 플로우 방향:**
- **Control Plane**: Client → Load Balancer → API Service → IAM → Metadata Service
- **Data Plane**: Client → Load Balancer → API Service → Data Service → Storage Backend

## 세부 컴포넌트 분석

### 1. Load Balancer
**역할**: 트래픽 분산 및 고가용성 보장
**책임**:
- 지리적 위치 기반 라우팅 (사용자를 가장 가까운 데이터센터로 연결)
- 라운드 로빈 알고리즘을 통한 API 서비스 인스턴스 간 부하 분산
- SSL/TLS 종료 및 헬스 체크
- 서비스 레벨 로드 밸런싱 (API, 메타데이터, 데이터 서비스 각각)

**연결 관계**: 클라이언트와 API Service 사이의 게이트웨이 역할

### 2. API Service (API Gateway)
**역할**: 모든 클라이언트 요청의 진입점
**책임**:
- HTTP 요청 검증 및 프로토콜 변환
- 인증/인가 통합 (IAM과 연동)
- 요청 라우팅 및 변환
- 속도 제한 및 스로틀링
- 응답 형식 표준화

**연결 관계**:
- 입력: Load Balancer로부터 요청 수신
- 출력: IAM Service, Metadata Service, Data Service와 통신

### 3. Identity and Access Management (IAM)
**역할**: 중앙화된 인증 및 권한 관리
**책임**:
- 사용자 신원 확인 및 인증
- 권한 관리 (READ/WRITE 액세스)
- 정책 시행 및 토큰 검증
- 세분화된 접근 제어 (버킷/객체 레벨)

**연결 관계**: API Service로부터 모든 요청에 대한 인증/인가 확인

### 4. Metadata Service
**역할**: 모든 버킷 및 객체 메타데이터 관리
**책임**:
- 버킷 메타데이터 저장 (버킷명, 지역, 생성일)
- 객체 메타데이터 관리 (object_id, bucket_id, 크기, 타임스탬프)
- 계층적 네임스페이스 관리
- 메타데이터 쿼리 및 업데이트

**데이터베이스 스키마**:
```sql
-- 객체 메타데이터 테이블
object_metadata:
  - object_id (UUID, Primary Key)
  - bucket_id (UUID, Foreign Key)
  - object_name (VARCHAR)
  - size (BIGINT)
  - creation_time (TIMESTAMP)
  - etag (VARCHAR)
  - storage_class (VARCHAR)

-- 버킷 메타데이터 테이블
bucket_metadata:
  - bucket_id (UUID, Primary Key)
  - bucket_name (VARCHAR, Unique)
  - region (VARCHAR)
  - creation_time (TIMESTAMP)
  - access_policies (JSON)
```

**특성**:
- 가변적 데이터 (메타데이터 업데이트 가능)
- 분산 데이터베이스 사용 (RocksDB 등)
- 강한 일관성 보장 (ACID 트랜잭션)
- 다중 노드 복제

### 5. Data Service
**역할**: 실제 객체 데이터 저장 및 관리
**책임**:
- 객체 데이터 영속성 및 검색
- 복제 및 erasure coding을 통한 내구성 보장
- 데이터 무결성 검증 (체크섬)
- 압축 및 스토리지 최적화

**하위 컴포넌트**:
- **Data Routing Service**: 무상태 서비스, 사용자 요청 처리
- **Placement Service**: 가상 클러스터 맵 유지, 데이터 노드 모니터링
- **Data Nodes**: 동기 복제를 통한 실제 데이터 저장

**특성**:
- 불변적 데이터 (write-once, read-many)
- UUID 기반 고유 식별자 반환
- 대용량 파일 효율적 처리
- Erasure coding (4+2) 및 3-copy 복제 지원

## 데이터 플로우 세부 프로세스

### 파일 업로드 프로세스
**단계별 플로우**:
1. **클라이언트** → HTTP PUT 요청 → **Load Balancer**
2. **Load Balancer** → 요청 라우팅 → **API Service**
3. **API Service** → 인증 확인 → **IAM Service**
4. **IAM** → 권한 검증 완료 → **API Service**
5. **API Service** → 객체 데이터 전송 → **Data Service**
6. **Data Service** → 데이터 저장 및 UUID 반환 → **API Service**
7. **API Service** → 메타데이터 생성 → **Metadata Service**
8. **Metadata Service** → 메타데이터 저장 완료 → **API Service**
9. **API Service** → 성공 응답 → **클라이언트**

### 멀티파트 업로드 (대용량 파일)
**프로세스**:
1. 클라이언트가 멀티파트 업로드 시작 → unique uploadID 반환
2. 파일을 여러 부분으로 분할 (권장: 8-16MB 크기)
3. 각 부분을 병렬로 업로드 → ETag(MD5 체크섬) 반환
4. 모든 부분 업로드 완료 → 완료 요청 전송
5. Data Service에서 부분 번호 기반으로 재조립

### 파일 다운로드 프로세스
**단계별 플로우**:
1. **클라이언트** → HTTP GET 요청 → **Load Balancer**
2. **Load Balancer** → **API Service** → **IAM Service** (인증)
3. **API Service** → 객체 위치 조회 → **Metadata Service**
4. **API Service** → 객체 데이터 검색 → **Data Service**
5. **Data Service** → 객체 데이터 반환 → **클라이언트**

### 파일 삭제 프로세스
**단계별 플로우**:
1. **클라이언트** → HTTP DELETE 요청 → **API Service**
2. **API Service** → 삭제 권한 확인 → **IAM Service**
3. **API Service** → 메타데이터 삭제 → **Metadata Service**
4. **API Service** → 객체 데이터 삭제 → **Data Service**
5. 성공 응답 반환

## 메타데이터 관리 방식

### 메타데이터 vs 객체 데이터 분리
**메타데이터 특성**:
- 가변적 (업데이트 가능)
- 빠른 접근 최적화
- 강한 일관성 요구
- 관계형 데이터베이스 패턴

**객체 데이터 특성**:
- 불변적 (한 번 작성, 여러 번 읽기)
- 대용량 데이터 처리 최적화
- 최종 일관성 허용
- 블록 기반 저장

## 데이터 저장 및 복제 전략

### 내구성 보장 방식
**Erasure Coding (4+2)**:
- 11-nines 내구성 (99.999999999%)
- 50% 저장 오버헤드
- 최대 2개 노드 장애 허용

**3-Copy 복제**:
- 6-nines 내구성 (99.9999%)
- 200% 저장 오버헤드
- 높은 가용성 보장

### 지리적 복제 전략
**Cross-Region Replication (CRR)**:
- 비동기 지역 간 복제
- 재해 복구 및 규정 준수
- 지연 시간 최소화

**Same-Region Replication (SRR)**:
- 동일 지역 내 복제
- 가용성 영역 간 분산
- 빠른 장애 복구

### 블록 레벨 저장
- 파일을 4MB 블록으로 분할
- 각 블록에 고유 해시 값 할당
- 독립적인 객체로 저장
- 중복 제거 및 압축 지원

## 일관성 모델

### 강한 일관성 (Modern S3 Approach)
**특성**:
- Read-after-write 일관성 (새 객체 즉시 읽기 가능)
- Read-after-update 일관성 (업데이트 즉시 반영)
- List 일관성 (쓰기 후 즉시 정확한 리스트)
- Delete 일관성 (삭제 즉시 반영)

**구현 방식**:
- 메타데이터 서브시스템의 고가용성 캐싱
- 분산 합의 알고리즘 (Paxos/Raft)
- 벡터 클록을 통한 충돌 해결

### 최종 일관성 (성능 최적화)
**적용 시나리오**:
- 성능이 중요한 경우
- 지리적으로 분산된 복제
- 대용량 데이터 처리

## 로드밸런싱 및 확장성

### 확장성 패턴
**수평 확장**:
- 모든 컴포넌트의 수평 확장 지원
- 일관된 해싱을 통한 데이터 분산
- 메타데이터와 데이터 서비스 독립 확장

**샤딩 전략**:
- 일관된 해싱 알고리즘 사용
- 핫스팟 완화를 위한 가상 노드
- 노드 추가/제거 시 최소 리밸런싱

### 병목 현상 해결
**작은 파일 문제**:
- 여러 작은 객체를 큰 파일로 병합
- 직렬화된 쓰기 작업
- I-node 용량 제한 해결

**성능 최적화**:
- 바이트 범위 요청 지원
- 동시 요청 처리
- 스토리지 클래스 최적화

## 캐싱 전략

### 다층 캐싱 아키텍처
**CDN 통합**:
- 엣지 위치에서 정적 콘텐츠 캐싱
- 지리적으로 분산된 콘텐츠 제공
- 브라우저 캐싱 지원

**애플리케이션 레벨 캐시**:
- 자주 접근되는 메타데이터 캐싱
- Redis/In-memory 캐시 활용
- TTL 기반 캐시 관리

**캐시 무효화 전략**:
- 시간 기반 만료 (TTL)
- 이벤트 기반 무효화
- 분산 캐시 일관성 보장

## 보안 및 인증 메커니즘

### 인증 및 권한 부여
**IAM 통합**:
- 중앙화된 사용자 신원 관리
- 세분화된 권한 제어 (버킷/객체 레벨)
- 역할 기반 접근 제어 (RBAC)
- 임시 액세스 토큰 지원

**접근 제어**:
- 액세스 제어 목록 (ACL)
- 버킷 정책 및 객체 정책
- 서명된 URL을 통한 임시 액세스
- 다단계 인증 지원

### 데이터 보호
**암호화**:
- 저장 시 암호화 (AES-256)
- 전송 중 암호화 (HTTPS/TLS)
- 키 관리 서비스 통합
- 클라이언트측 암호화 지원

**보안 모니터링**:
- 포괄적인 감사 로그
- 실시간 보안 모니터링
- 이상 탐지 및 알림
- 규정 준수 보고

## Figma 다이어그램용 컴포넌트 정리

### High-Level Architecture Diagram 구성요소

**메인 컴포넌트 (왼쪽→오른쪽 배치)**:
```
[Client] → [Load Balancer] → [API Service] → [IAM Service]
                                   ↓
                    [Metadata Service] ← → [Data Service]
                           ↓                      ↓
                [Metadata Database]    [Distributed Storage]
```

**연결선 표시**:
- 실선: 동기 통신
- 점선: 비동기 통신
- 굵은 화살표: 데이터 플로우
- 가는 화살표: 제어 신호

### 세부 컴포넌트 다이어그램

**Data Service 내부 구조**:
```
[Data Routing Service] → [Placement Service] → [Data Nodes]
                                ↓
                        [Virtual Cluster Map]
```

**캐싱 레이어**:
```
[CDN] → [API Gateway Cache] → [Metadata Cache] → [Application Cache]
```

**보안 레이어**:
```
[SSL/TLS] → [IAM] → [Access Control] → [Encryption]
```